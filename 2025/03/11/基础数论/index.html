<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>基础数论 | wyf 的个人博客</title><meta name="author" content="wyf"><meta name="copyright" content="wyf"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="蓝桥杯基础数论算法">
<meta property="og:type" content="article">
<meta property="og:title" content="基础数论">
<meta property="og:url" content="https://wyf-blog.github.io/2025/03/11/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/index.html">
<meta property="og:site_name" content="wyf 的个人博客">
<meta property="og:description" content="蓝桥杯基础数论算法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wyf-blog.github.io/img/logo.jpg">
<meta property="article:published_time" content="2025-03-11T05:31:14.227Z">
<meta property="article:modified_time" content="2025-03-11T06:02:06.062Z">
<meta property="article:author" content="wyf">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="蓝桥杯">
<meta property="article:tag" content="基础数论">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wyf-blog.github.io/img/logo.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "基础数论",
  "url": "https://wyf-blog.github.io/2025/03/11/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/",
  "image": "https://wyf-blog.github.io/img/logo.jpg",
  "datePublished": "2025-03-11T05:31:14.227Z",
  "dateModified": "2025-03-11T06:02:06.062Z",
  "author": [
    {
      "@type": "Person",
      "name": "wyf",
      "url": "https://wyf-blog.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://wyf-blog.github.io/2025/03/11/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '基础数论',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200804140414.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">wyf 的个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">基础数论</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">基础数论</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-11T05:31:14.227Z" title="发表于 2025-03-11 13:31:14">2025-03-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-11T06:02:06.062Z" title="更新于 2025-03-11 14:02:06">2025-03-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/">蓝桥杯</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="蓝桥杯基础数论学习笔记"><a href="#蓝桥杯基础数论学习笔记" class="headerlink" title="蓝桥杯基础数论学习笔记"></a>蓝桥杯基础数论学习笔记</h1><h3 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h3><ol>
<li>素数（素数个数、最小素数，欧拉函数）</li>
<li>约数（约数个数公式） </li>
<li>幂 （快速幂）</li>
<li>阶乘 （阶乘的递推形式、阶乘与因数）</li>
<li>取模 （加减乘取模与除法取模、乘法逆元、中国剩余定理（待更新））</li>
<li>异或与异或和</li>
</ol>
<h2 id="一、素数"><a href="#一、素数" class="headerlink" title="一、素数"></a>一、素数</h2><blockquote>
<p>素数又称质数，一个<strong>大于1</strong>且只能被1和它本身整除的数被称为素数。对素数的求解往往是解决素数和约数问题的基础。</p>
</blockquote>
<h3 id="（1）求解方法"><a href="#（1）求解方法" class="headerlink" title="（1）求解方法"></a>（1）求解方法</h3><p>素数的求解有试除法、埃氏筛和线性筛三种求法，其中线性筛效率最高，此处只列出线性筛代码，因为线性筛不仅效率高，还可以方便地求出每个数的最小质因数，用途更广。<br>注意在考试的时候尽量打表，蓝桥杯的内存限制比较宽，一般不会出现内存溢出。不要让素数的搜索占用宝贵的程序运行时间。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线性筛</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sieve</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># find out all of the prime numbers between 2 and n</span></span><br><span class="line">    prime = []</span><br><span class="line">    is_prime = [<span class="literal">True</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> is_prime[i]:</span><br><span class="line">            prime.append(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> prime:</span><br><span class="line">            <span class="comment"># 注意这三个操作的顺序不可调换</span></span><br><span class="line">            <span class="keyword">if</span> i*j &gt; n:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            is_prime[i*j] = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> i%j == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 只用最小的质因数筛除非质数，减少了重复的运算</span></span><br><span class="line">                <span class="comment"># 因为j已经筛过一遍了，所以不需要用i重复筛了</span></span><br><span class="line">                <span class="keyword">break</span>           </span><br><span class="line">    <span class="keyword">return</span> prime</span><br></pre></td></tr></table></figure>
<p>只需要对线性筛算法中筛除非质数的部分进行修改，在筛除某个值的同时记录筛除它的数即可</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sieve</span>(<span class="params">n</span>):</span><br><span class="line">    prime = []</span><br><span class="line">    is_prime = [<span class="literal">True</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    min_prime = [<span class="number">1</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> is_prime[i]:</span><br><span class="line">            prime.append(i)</span><br><span class="line">            <span class="comment"># 素数的最小质因子是它本身</span></span><br><span class="line">            min_prime[i] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> prime:</span><br><span class="line">            <span class="keyword">if</span> i*j &gt; n:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            is_prime[i*j] = <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 在排除数字i*j的同时记录它的最小质因子j</span></span><br><span class="line">            <span class="comment"># 注意此处i不一定是质数</span></span><br><span class="line">            min_prime[i*j] = j</span><br><span class="line">            <span class="keyword">if</span> i%j == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> min_prime</span><br></pre></td></tr></table></figure>
<h3 id="（2）求最小质因数"><a href="#（2）求最小质因数" class="headerlink" title="（2）求最小质因数"></a>（2）求最小质因数</h3><p>对于一个给定正整数，只需要从2开始逐个试除，第一个能够整除n的数就是其最小质因数。这个方法可以用反证法证明，如果第一个整除n的数是一个合数，那么n也一定可以被这个合数的每一个因数所整除，又因为合数存在小于其本身的因数，所以这个合数一定不是第一个能够整除n的数，这与假设矛盾，故原结论得证。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> n%i == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h3 id="（3）欧拉函数"><a href="#（3）欧拉函数" class="headerlink" title="（3）欧拉函数"></a>（3）欧拉函数</h3><p>欧拉函数有一个输入n，返回所有小于等于n的数中与n互质的数的个数</p>
<h4 id="性质一：欧拉函数的计算式"><a href="#性质一：欧拉函数的计算式" class="headerlink" title="性质一：欧拉函数的计算式"></a>性质一：欧拉函数的计算式</h4><blockquote>
<p>$\varphi(a) &#x3D; (1 - \frac 1 p_1)*(1 - \frac 1 p_2)…(1 - \frac 1 p_n)$<br>其中 $p_i$ 是 $n$ 的所有质因子，如果 $n$ 中存在多个重复的质因子，这个质因子只计算一次</p>
</blockquote>
<h4 id="性质二：欧拉函数的分解"><a href="#性质二：欧拉函数的分解" class="headerlink" title="性质二：欧拉函数的分解"></a>性质二：欧拉函数的分解</h4><blockquote>
<p>如果 $(a%b &#x3D;&#x3D; 0 且 (a&#x2F;&#x2F;b)%b &#x3D;&#x3D; 0)$ 则有 $\varphi(a) &#x3D; \varphi(a&#x2F;&#x2F;b)<em>b$<br>如果 $(a%b &#x3D;&#x3D; 0 且 (a&#x2F;&#x2F;b)%b !&#x3D; 0)$ 则有 $\varphi(a) &#x3D; \varphi(a&#x2F;&#x2F;b)</em>(b-1)$</p>
</blockquote>
<h4 id="推论一："><a href="#推论一：" class="headerlink" title="推论一："></a>推论一：</h4><blockquote>
<p>由性质二可知，$\varphi(a^b) &#x3D; \varphi(a) * a^{b-1}$</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用性质一计算欧拉函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">euler</span>(<span class="params">n</span>):</span><br><span class="line">    res = n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n%i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> n%i == <span class="number">0</span>:</span><br><span class="line">                n //= i</span><br><span class="line">            res = res//i*(i-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        res = res // n * (n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>
<h3 id="（4）例题演示"><a href="#（4）例题演示" class="headerlink" title="（4）例题演示"></a>（4）例题演示</h3><h4 id="例题-1：分解质因数"><a href="#例题-1：分解质因数" class="headerlink" title="例题 1：分解质因数**"></a>例题 1：分解质因数**</h4><p><strong>题目描述：</strong></p>
<blockquote>
<p>求出区间[a,b]中所有整数的质因数分解。</p>
</blockquote>
<p><strong>输入:</strong></p>
<blockquote>
<p>输入一行，包含两个用空格分割的正整数，分别表示 a 和 b。</p>
</blockquote>
<p><strong>输出:</strong></p>
<blockquote>
<p>每行输出一个数的分解，形如 $k&#x3D;a_1* a_2 *a_3… (a_1&lt;&#x3D;a_2&lt;&#x3D;a_3…，k也是从小到大的)$</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BF做法：直接对每一个在区间[a,b]内的数从2开始试除，但由于时间复杂度过高，一定会超时</span></span><br><span class="line"><span class="comment"># firstly,find out all the prime number that are smaller than n+1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sieve</span>(<span class="params">n</span>):</span><br><span class="line">    prime = []</span><br><span class="line">    is_prime = [<span class="literal">True</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> is_prime[i]:</span><br><span class="line">            prime.append(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> prime:</span><br><span class="line">            <span class="keyword">if</span> i*j &gt; n:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            is_prime[i*j] = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> i%j == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> prime</span><br><span class="line"><span class="comment"># main part</span></span><br><span class="line">a,b = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">prime = sieve(b)</span><br><span class="line"><span class="comment"># divide every number in the interval</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a, b+<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span> = &#x27;</span>, end = <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment"># create a string to store the result of division</span></span><br><span class="line">    line = [] </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> prime:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">while</span> i%j == <span class="number">0</span>:</span><br><span class="line">            line.append(<span class="built_in">str</span>(j))</span><br><span class="line">            line.append(<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            i //= j</span><br><span class="line">    <span class="comment"># print the result of division</span></span><br><span class="line">    line.pop(-<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(line))</span><br></pre></td></tr></table></figure>
<h4 id="例题-2：互质数的个数"><a href="#例题-2：互质数的个数" class="headerlink" title="例题 2：互质数的个数"></a>例题 2：互质数的个数</h4><p><strong>题目描述：</strong></p>
<blockquote>
<p>给定 a,b，求 $1 ≤ x ＜ a^b$中有多少个 $x$ 与 $a^b$。由于答案可能很大，你只需要输出答案对 998244353 取模的结果。</p>
</blockquote>
<p><strong>输入:</strong></p>
<blockquote>
<p>输入一行，包含两个用空格分割的正整数，分别表示 a 和 b。</p>
</blockquote>
<p><strong>输出:</strong></p>
<blockquote>
<p>输出一行包含一个整数表示答案。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 带入欧拉公式推论一</span></span><br><span class="line"><span class="comment"># 快速幂 + 欧拉公式</span></span><br><span class="line">MOD = <span class="number">998244353</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">qpow</span>(<span class="params">a,n</span>):</span><br><span class="line">    ans = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        <span class="keyword">if</span> n&amp;<span class="number">1</span>:</span><br><span class="line">            <span class="comment"># n is odd</span></span><br><span class="line">            ans = ans * a % MOD</span><br><span class="line">        a = a * a % MOD</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">euler</span>(<span class="params">n</span>):</span><br><span class="line">    res = n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n%i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> n%i == <span class="number">0</span>:</span><br><span class="line">                n //= i</span><br><span class="line">            res = res//i*(i-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        res = res//n*(n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">a,b = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line"><span class="keyword">if</span> a == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(euler(a) * qpow(a,b-<span class="number">1</span>) % MOD) </span><br></pre></td></tr></table></figure>


<h2 id="二、约数"><a href="#二、约数" class="headerlink" title="二、约数"></a>二、约数</h2><blockquote>
<p>约数又称因数，整数a除以非零整数b，除得的商正好是整数，余数为0，就说a能够被b整除，a是b的倍数，b是a的约数。</p>
</blockquote>
<h3 id="（1）求约数个数"><a href="#（1）求约数个数" class="headerlink" title="（1）求约数个数"></a>（1）求约数个数</h3><p><strong>约数个数定理：</strong></p>
<blockquote>
<p>对任意一个大于1的正整数 $X$ 都可以表示为若干个质数乘积的格式，即 $X &#x3D; P_1^{a_1} * P_2^{a_2} * … * P_k^{a_k}$，则约数的个数就是 $(a_1 + 1)<em>(a_2 + 1)</em>…*(a_k + 1)$，注意这个结果中的约数包含1。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="comment"># calculate out the prime numbers that smaller than the given number</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sieve</span>(<span class="params">n</span>):</span><br><span class="line">    prime = []</span><br><span class="line">    is_prime = [<span class="literal">True</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> is_prime[i]:</span><br><span class="line">            prime.append(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> prime:</span><br><span class="line">            <span class="keyword">if</span> i*j &gt; n:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            is_prime[i*j] = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> i%j == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> prime</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">prime = sieve(n)</span><br><span class="line"><span class="comment"># divide the given number by these prime numbers</span></span><br><span class="line"><span class="comment"># use a defaultdict to record the times that every number appear in the given number</span></span><br><span class="line">d = defaultdict(<span class="built_in">int</span>) </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> prime:</span><br><span class="line">    <span class="keyword">while</span> n%i == <span class="number">0</span>:</span><br><span class="line">        d[i] += <span class="number">1</span></span><br><span class="line">        n //= i</span><br><span class="line"><span class="comment"># use the data to figure out the answer</span></span><br><span class="line">ans = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> d.values():</span><br><span class="line">    ans *= (i+<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure>
<h3 id="（2）求所有的约数"><a href="#（2）求所有的约数" class="headerlink" title="（2）求所有的约数"></a>（2）求所有的约数</h3><p>求约数的个数主要还是使用试除法，因为先计算所有质因数然后组合的时间复杂度过高，但也应注意到可以使用适当的优化提升算法的效率。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BF algorithm</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> i &gt; (n//i):</span><br><span class="line">        <span class="comment"># all of the numbers that bigger than this value have alreadly been recorded</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> n%i == <span class="number">0</span>:</span><br><span class="line">        res.append(i)</span><br><span class="line">        n //= i</span><br><span class="line">        <span class="comment"># record the number that left as well</span></span><br><span class="line">        <span class="keyword">if</span> n != i:</span><br><span class="line">            res.append(n)</span><br><span class="line">res.sort()</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h3 id="（3）最大公因数"><a href="#（3）最大公因数" class="headerlink" title="（3）最大公因数"></a>（3）最大公因数</h3><p>求两个数的最大公因数的方法有辗转相除法和更相减损术等，此处只介绍应用范围更广且时间复杂度更小的辗转相除法。辗转相除法，又名欧几里得算法，是一种可以利用递归或递推快速求除出两数最大公因数的算法，时间复杂度为 $O(logn)$。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 欧几里得算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">return</span> gcd(b,a%b)</span><br></pre></td></tr></table></figure>
<p>欧几里得算法既可以在考场时自己实现，也可以直接调用python的math标准库中的gcd()函数。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> gcd</span><br><span class="line">m = <span class="number">10</span></span><br><span class="line">n = <span class="number">6</span></span><br><span class="line"><span class="built_in">print</span>(gcd(m,n)) <span class="comment"># output:2</span></span><br></pre></td></tr></table></figure>
<h3 id="（4）最小公倍数"><a href="#（4）最小公倍数" class="headerlink" title="（4）最小公倍数"></a>（4）最小公倍数</h3><p><strong>求解定理：</strong></p>
<blockquote>
<p>最小公倍数 &#x3D; 两数之积 &#x2F;&#x2F; 最大公因数</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> gcd</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gbs</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a*b//gcd(a,b)</span><br></pre></td></tr></table></figure>
<h2 id="三、幂"><a href="#三、幂" class="headerlink" title="三、幂"></a>三、幂</h2><p>幂的运算可以使用python的运算符**实现，也可以自行建立快速幂函数。快速幂算法的时间复杂度是 $O(logn)$ ，虽然Python中有内嵌函数pow()，但调用的运行效率明显较低，最好自己写。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">qpow</span>(<span class="params">a,n,mod</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        <span class="keyword">if</span> n&amp;<span class="number">1</span>:</span><br><span class="line">            <span class="comment"># n is an odd number</span></span><br><span class="line">            res = res * a % mod</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span> <span class="comment"># n need to be divided by 2</span></span><br><span class="line">        a = a * a % mod</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="四、阶乘"><a href="#四、阶乘" class="headerlink" title="四、阶乘"></a>四、阶乘</h2><p>阶乘是蓝桥杯的高频考点，基本上每年都有一道题，大部分是简单填空题，但大题还是比较难的，<br>主要需要注意其递推特性($n! &#x3D; n*(n-1)!$)和n与约数之间的关系。这里列出两道题目，分别涵盖以上两个难点。</p>
<h3 id="例题-1：求阶乘（蓝桥杯第13届省赛真题）"><a href="#例题-1：求阶乘（蓝桥杯第13届省赛真题）" class="headerlink" title="例题 1：求阶乘（蓝桥杯第13届省赛真题）"></a>例题 1：求阶乘（蓝桥杯第13届省赛真题）</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>满足 $N!$ 的末尾恰好有 $K$ 个0的最小的 $N$ 是多少？输出这个数。如果这样的 $N$ 不存在，输出-1</p>
</blockquote>
<p><strong>输入格式：</strong></p>
<blockquote>
<p>输入一行，包含一个整数，表示k</p>
</blockquote>
<p><strong>输出格式：</strong></p>
<blockquote>
<p>输出一行，包含一个整数</p>
</blockquote>
<p><strong>提示：</strong></p>
<blockquote>
<p>对于 $30%$ 的数据，$1 \leq K \leq 10^6$,<br>对于 $100%$ 的数据，$1 \leq K \leq 10^{18}$</p>
</blockquote>
<p><strong>代码示例：</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴力做法，只能通过40%的样例</span></span><br><span class="line"><span class="comment"># 0只能通过乘以10的倍数或5的倍数获得，因为2的倍数远多于5的倍数，所以不用考虑</span></span><br><span class="line"><span class="comment"># 100，1200之类的数需要特别处理</span></span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> exit</span><br><span class="line"></span><br><span class="line">k = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="comment"># 从5开始，以5为步长搜索5的倍数和10的倍数</span></span><br><span class="line">n = <span class="number">0</span> <span class="comment"># 记录当前遍历到的因数</span></span><br><span class="line">cur = <span class="number">0</span> <span class="comment"># 记录当前所得到的0的个数</span></span><br><span class="line"><span class="keyword">while</span> cur &lt; k:</span><br><span class="line">    n += <span class="number">5</span></span><br><span class="line">    <span class="comment"># 先将n末尾所有的0转移到cur上</span></span><br><span class="line">    temp = n</span><br><span class="line">    <span class="keyword">while</span> temp%<span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">        temp //= <span class="number">10</span></span><br><span class="line">        cur += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 然后统计temp中5的个数</span></span><br><span class="line">    <span class="keyword">while</span> temp%<span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">        temp //= <span class="number">5</span></span><br><span class="line">        cur += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> cur == k:</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>注意到对于一个给定的 $n!$，末尾0的个数 &#x3D; 从1到n各个数字的约数中5的个数 &#x3D; k<br>$k &#x3D; \frac n {5^1} + \frac n {5^2} + \frac n {5^3} + …$ 可以高效地求出指定n!的末尾0个数，所以可以使用二分法提高查找效率。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Binary Search Optimize</span></span><br><span class="line"><span class="comment"># 注意到末尾0的个数随n的增大只会增大，不会减小，且结果的末尾0个数有大于等于k和小于k两种状态，所以可以使用二分法高效求解</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 求出 n! 末尾0的个数</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 这个过程的实质是求出构成阶乘的数字中所有5的倍数，25的倍数，125的倍数...</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        n //= <span class="number">5</span></span><br><span class="line">        res += n</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># binary search main part</span></span><br><span class="line">k = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">left = <span class="number">1</span></span><br><span class="line">right = <span class="number">10</span>**<span class="number">19</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">    mid = (left+right)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> check(mid) &lt; k:</span><br><span class="line">        left = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># mid 可能是正确答案，所以不能舍弃</span></span><br><span class="line">        right = mid</span><br><span class="line"><span class="comment"># left = right</span></span><br><span class="line"><span class="keyword">if</span> check(left) == k:</span><br><span class="line">    <span class="comment"># 存在解</span></span><br><span class="line">    <span class="built_in">print</span>(left)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="例题-2：阶乘的和（蓝桥杯第14届省赛真题）"><a href="#例题-2：阶乘的和（蓝桥杯第14届省赛真题）" class="headerlink" title="例题 2：阶乘的和（蓝桥杯第14届省赛真题）"></a>例题 2：阶乘的和（蓝桥杯第14届省赛真题）</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>给定 n 个数 $A_i$，问能满足 m! 为 $∑_{i&#x3D;1}^n(A_i!)$ 的因数的最大的 m 是多少。其中 m! 表示 m 的阶乘，即 $1 × 2 × 3 × · · · × m$。</p>
</blockquote>
<p><strong>输入格式：</strong></p>
<blockquote>
<p>输入的第一行包含一个整数 n 。<br>第二行包含 n 个整数，分别表示 $A_i$，相邻整数之间使用一个空格分隔。</p>
</blockquote>
<p><strong>输出格式：</strong></p>
<blockquote>
<p>输出一行包含一个整数表示答案。</p>
</blockquote>
<p><strong>提示：</strong></p>
<blockquote>
<p>对于 $40%$ 的评测用例，$n ≤ 5000$ ；<br>对于所有评测用例，$1 ≤ n ≤ 10^5,1 ≤ A_i ≤ 10^9$ </p>
</blockquote>
<p><strong>解题思路：</strong><br>在极限情况下，a数组中各个值均只出现一次，各阶乘无法合并，那么m! &#x3D; a[0]!,a[0] &#x3D; min(a)<br>本题中各个a[i]可能重复出现，因此存在合并阶乘的可能(比如n!*(n+1) &#x3D; (n+1)!)，所以m! &#x3D; min(s)<br>s是合并化简后的a数组各元素阶乘和式子中阶乘元素的集合<br>通过以上分析可知m!应当是分子中各个阶乘合并后最小的阶乘<br>通过分治求出合并后的最小阶乘<br>temp &#x3D; (x*a[0] + y*(a[0]+1)),x,y分别是a[0],a[0]+1在a中的个数<br>显然a[0]&lt;&#x3D;m，现在要看合并结果是否是a[0]+1的倍数，(a[0]+1)*y显然是(a[0]+1)的倍数</p>
<blockquote>
<p>倍数性质：m的倍数+不是m倍数的数，则结果一定不是m的倍数</p>
</blockquote>
<p>由倍数定律可知如果x*a[0]是(a[0]+1)的倍数，则temp就是(a[0]+1)的倍数<br>又因为gcd(a[0],a[0]+1) &#x3D; 1，所以‘x*a[0]是(a[0]+1)的倍数’等价于x是(a[0]+1)的倍数</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">a = <span class="built_in">sorted</span>([<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">input</span>().split()])</span><br><span class="line"><span class="comment"># 从最小的a[0]开始递推</span></span><br><span class="line"><span class="comment"># 创建一个变量记录当前阶乘的系数</span></span><br><span class="line">k = <span class="number">1</span></span><br><span class="line"><span class="comment"># 创建一个变量记录当前阶乘的值</span></span><br><span class="line">cur = a[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">    <span class="keyword">if</span> cur == a[i]:</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># cur &lt; a[i]</span></span><br><span class="line">        <span class="comment"># 检查系数是否能够合并进当前阶乘中</span></span><br><span class="line">        <span class="keyword">while</span> k%(cur+<span class="number">1</span>) == <span class="number">0</span> <span class="keyword">and</span> k//(cur+<span class="number">1</span>) != <span class="number">0</span>:</span><br><span class="line">            cur += <span class="number">1</span></span><br><span class="line">            k //= cur</span><br><span class="line">            <span class="keyword">if</span> cur == a[i] :</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 无法达到a[i]</span></span><br><span class="line">        <span class="keyword">if</span> cur &lt; a[i]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 成功到达a[i]</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(cur)</span><br></pre></td></tr></table></figure>
<h2 id="五、取模"><a href="#五、取模" class="headerlink" title="五、取模"></a>五、取模</h2><p>竞赛题中常要求将较大的答案取模后输出，由于答案超出表示范围，所以不能先算出答案然后取模。此时，我们需要考虑如何在计算过程中进行取模才能获得所需答案。</p>
<h3 id="（1）加减乘中的取模运算"><a href="#（1）加减乘中的取模运算" class="headerlink" title="（1）加减乘中的取模运算"></a>（1）加减乘中的取模运算</h3><p>加减法和乘法对取模运算是 <strong>封闭</strong> 的，也就是所在加减操作中添加取模运算时，既可以先分别对操作数进行取模然后运算，也可以先运算然后对结果取模，这两种方式所得结果是相同的。</p>
<blockquote>
<p>(12 + 3)%10 &#x3D; 5<br>12%10 &#x3D; 2, 3%10 &#x3D; 3<br>2 + 3 &#x3D; 5</p>
</blockquote>
<h3 id="（2）除法中的取模运算"><a href="#（2）除法中的取模运算" class="headerlink" title="（2）除法中的取模运算"></a>（2）除法中的取模运算</h3><p>在除法运算中，先取模后运算将会得到错误答案，为了解决这一问题，学者引入了逆元。要求除法取模统一使用逆元解决。</p>
<h3 id="（3）逆元"><a href="#（3）逆元" class="headerlink" title="（3）逆元"></a>（3）逆元</h3><blockquote>
<p>相关资料：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/449221995">逆元 —— 广义化的倒数</a></p>
</blockquote>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逆元的求解 —— 拓展欧几里得</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exgcd</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> a,<span class="number">1</span>,<span class="number">0</span></span><br><span class="line">    x1,y1,gcd = exgcd(b, a%b)</span><br><span class="line">    x = y1</span><br><span class="line">    y = x1 - (a//b)*y1</span><br><span class="line">    <span class="keyword">return</span> gcd,x,y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逆元求解主函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inv</span>(<span class="params">a, p</span>):</span><br><span class="line">    gcd, x, y = exgcd(a, p)</span><br><span class="line">    <span class="keyword">if</span> gcd != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;The modular inverse does not exist for <span class="subst">&#123;a&#125;</span> mod <span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 返回 x%p 的结果</span></span><br><span class="line">    <span class="keyword">return</span> (x % p + p) % p</span><br></pre></td></tr></table></figure>

<h2 id="六、异或-异或和"><a href="#六、异或-异或和" class="headerlink" title="六、异或 &amp; 异或和"></a>六、异或 &amp; 异或和</h2><p>异或操作是一种常用的二进制位运算，当两个操作数相同位上的数值不同时结果为1，数值相同的时候为0\</p>
<h3 id="（1）基本性质"><a href="#（1）基本性质" class="headerlink" title="（1）基本性质"></a>（1）基本性质</h3><ol>
<li>交换律：(a ^ b) &#x3D; (b ^ a)</li>
<li>结合律：(a ^ b) ^ c &#x3D; a ^ (b ^ c)</li>
<li>对于任何数x，都有x ^ x&#x3D;0，x ^ 0 &#x3D; x</li>
<li>自反性：a ^ b ^ b &#x3D; a,  a ^ 0 &#x3D; a</li>
</ol>
<h3 id="例题-1：异或和（蓝桥杯第14届省赛）"><a href="#例题-1：异或和（蓝桥杯第14届省赛）" class="headerlink" title="例题 1：异或和（蓝桥杯第14届省赛）"></a>例题 1：异或和（蓝桥杯第14届省赛）</h3><p><strong>问题描述：</strong></p>
<blockquote>
<p>给一棵含有 $n$ 个结点的有根树，根结点为 $1$ ，编号为 $i$ 的点有点权 $a_i$ $（i \in [1,n]）$。现在有两种操作，格式如下：<br>$1 x y$ ：该操作表示将点 $x$ 的点权改为 $y$。<br>$2 x$ ：该操作表示查询以结点 $x$ 为根的子树内的所有点的点权的异或和。<br>现有长度为 $m$ 的操作序列，请对于每个第二类操作给出正确的结果。</p>
</blockquote>
<p><strong>输入格式:</strong></p>
<blockquote>
<p>输入的第一行包含两个正整数 $n,m$ 用一个空格分隔。第二行包含 $n$ 个整数 $a_1, a_2, … ,a_n<br>，相邻整数之间使用一个空格分隔。接下来 $n−1$ 行，每行包含两个正整数 $u_i, v_i$，表示结点 $u_i$ 和 $v_i$之间有一条边。接下来 $m$ 行，每行包含一个操作。</p>
</blockquote>
<p><strong>输出格式:</strong></p>
<blockquote>
<p>输出若干行，每行对应一个查询操作的答案。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求 DFS 序，以便建立树状数组</span></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">cur,pre</span>):</span><br><span class="line">    <span class="comment"># cur 是当前节点的序号，pre是上一个节点的序号</span></span><br><span class="line">    <span class="keyword">global</span> cnt</span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 记录将当前节点压入栈中的时间戳</span></span><br><span class="line">    seq[cur][<span class="number">0</span>] = cnt </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tree[cur]:</span><br><span class="line">        <span class="keyword">if</span> pre != i:</span><br><span class="line">            dfs(i,cur)</span><br><span class="line">    <span class="comment"># 记录将当前元素出栈的时间戳，自此以后的时间戳均与以cur为根节点的树无关</span></span><br><span class="line">    seq[cur][<span class="number">1</span>] = cnt </span><br><span class="line"></span><br><span class="line"><span class="comment"># 树状数组函数三件套</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lowbit</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modify</span>(<span class="params">x,v</span>):</span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    <span class="keyword">while</span> x &lt;= n:</span><br><span class="line">        t[x] ^= v <span class="comment"># 计算异或和</span></span><br><span class="line">        x += lowbit(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">        ans ^= t[x]</span><br><span class="line">        x -= lowbit(x)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收输入，创建数据结构</span></span><br><span class="line">n,m = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line"><span class="comment"># a[]存储每一个点的权值</span></span><br><span class="line">a = [<span class="number">0</span>] + [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用邻接表存储树结构</span></span><br><span class="line">tree = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">    u,v = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    <span class="comment"># 注意没说方向，是一个无向边</span></span><br><span class="line">    tree[u].append(v)</span><br><span class="line">    tree[v].append(u)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个二维数组seq[][]记录DFS序</span></span><br><span class="line"><span class="comment"># 其中seq[i]是有2个元素的列表，两个元素分别是第i个节点入栈和出栈的时间戳</span></span><br><span class="line">seq = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为DFS序数组创建树状数组，并用a[]的值初始化</span></span><br><span class="line">t = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    modify(seq[i][<span class="number">0</span>], a[i])</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    instr = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">    <span class="keyword">if</span> instr[<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 修改元素，注意到需要在赋值的同时清除原有元素，所以将原值与新值异或，相当于清除原值</span></span><br><span class="line">        modify(seq[instr[<span class="number">1</span>]][<span class="number">0</span>], a[instr[<span class="number">1</span>]]^instr[<span class="number">2</span>])</span><br><span class="line">        <span class="comment"># 维护a[]，确保其始终保存着每一个节点的当前值</span></span><br><span class="line">        a[instr[<span class="number">1</span>]] = instr[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 输出单点查询结果 </span></span><br><span class="line">        <span class="built_in">print</span>(query(seq[instr[<span class="number">1</span>]][<span class="number">1</span>]) ^ query(seq[instr[<span class="number">1</span>]][<span class="number">0</span>] - <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://wyf-blog.github.io">wyf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wyf-blog.github.io/2025/03/11/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/">https://wyf-blog.github.io/2025/03/11/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://wyf-blog.github.io" target="_blank">wyf 的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/">蓝桥杯</a><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/">基础数论</a></div><div class="post-share"><div class="social-share" data-image="/img/logo.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/11/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a><a class="pagination-related" href="/2025/03/11/%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="并查集"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">并查集</div></div><div class="info-2"><div class="info-item-1">并查集 + Tarjan 算法 并查集是一种用于找出一个森林（图）中树（连通分支）的个数的算法，也可用于判断两个节点是否在同一棵树上。它在每一棵树（连通分支）上选择一个节点作为本棵树（连通分支）的代表。对于给定两个节点，如果他们具有相同的代表节点，则说明两个节点在同一个节点上。  一、并查集的简单应用例题 1：城市群的数量题目描述：  魔法大陆上有 n 个城市，编号为 1 到 n。城市与城市之间的道路均为双向道路，共有 m 条双向道路，并非任意两个城市之间都有双向道路。问，魔法大陆上有多少个城市群？若两个城市之间存在一条双向道路，则两个城市属于同一个城市群。任意两个城市之间最多只有一条双向道路。  输入格式：  第一行包含两个整数 n,m，含义与问题描述中相同。接下来 m 行，每行包含两个整数 u,v，表示城市 u 和城市 v 之间存在一条双向道路。  输出格式：  输出共一行，包含一个整数，表示城市群的数量。  代码示例： 123456789101112131415161718192021222324252627282930313233343536373839# DFS...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/03/11/BFS/" title="BFS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-11</div><div class="info-item-2">BFS</div></div><div class="info-2"><div class="info-item-1">BFSBFS算法主要有洪水填充（flood fill）和最短路径两个应用。 一、洪水填充算法（Flood Fill）例题 1：岛屿个数（第14届省赛真题）题目描述：  小蓝得到了一副大小为 M × N 的格子地图，可以将其视作一个只包含字符‘0’（代表海水）和 ‘1’（代表陆地）的二维数组，地图之外可以视作全部是海水，每个岛屿由在上&#x2F;下&#x2F;左&#x2F;右四个方向上相邻的 ‘1’ 相连接而形成。在岛屿 A 所占据的格子中，如果可以从中选出 k 个不同的格子，使得他们的坐标能够组成一个这样的排列：$(x_0, y_0),(x_1, y_1), . . . ,(x_{k−1}, y_{k−1})，其中(x_{(i+1)%k} , y_{(i+1)%k}) 是由 (x_i , y_i)$ 通过上&#x2F;下&#x2F;左&#x2F;右移动一次得来的 (0 ≤ i ≤ k − 1)，此时这 k 个格子就构成了一个 “环”。如果另一个岛屿 B 所占据的格子全部位于这个 “环” 内部，此时我们将岛屿 B 视作是岛屿 A 的子岛屿。若 B 是 A 的子岛屿，C 又是 B...</div></div></div></a><a class="pagination-related" href="/2025/03/11/%E4%BA%8C%E5%88%86%E6%B3%95/" title="二分法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-11</div><div class="info-item-2">二分法</div></div><div class="info-2"><div class="info-item-1">一、用途在数组中查找某一特定值的函数并获取其下标。 二、限制条件1.有序数组所查找的数组中的所有元素必须按照从小到大或从大到小的顺序排列。如果所查找的数组不是有序数组，也可使用sort()库函数将其转化为升序排列的有序数组后再进行查找。其中sort()函数位于C++的algorithm库中，其具体用法如下： 12345678910#include &lt;iostream&gt;                     #include &lt;algorithm&gt;using namespace std;                    // sort()函数位于标准库中int arr[] = &#123;0,2,1,3,7,4,3,2,5&#125;;int n = sizeof(arr)/sizeof(arr[0]);     // n为数组的长度// 默认为升序排序sort(arr, arr + n);                    // 降序排列sort(arr, arr + n, greater&lt;int&gt;());    ...</div></div></div></a><a class="pagination-related" href="/2025/03/11/%E5%85%A8%E6%8E%92%E5%88%97/" title="全排列问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-11</div><div class="info-item-2">全排列问题</div></div><div class="info-2"><div class="info-item-1">全排列全排列主要结合DFS求出一个数组中所有数字的排列结果，这个结果往往需要从小到大排列。此外，全排列还经常要求出某一个排列的前一个排列或后一个排列，此时需要用到 pre_permutation() 和 next_permutation()  算法模板123456789101112131415161718192021222324252627282930def next_permutation(nums):    n = len(nums)    # traversal the list from its end    # if find the first pair of numbers that is not inverse,begin to change its positon     for i in range(n-2,-1,-1):        if nums[i] &lt; nums[i+1]:            # begin to find the first number that are bigger than it            for j...</div></div></div></a><a class="pagination-related" href="/2025/03/11/%E5%89%8D%E7%BC%80%E5%92%8C&%E5%B7%AE%E5%88%86/" title="前缀和&amp;差分"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-11</div><div class="info-item-2">前缀和&amp;差分</div></div><div class="info-2"><div class="info-item-1">前缀和 &amp; 差分 前缀和与差分是常用的区间优化方式，其中前缀和数组可以将区间查询的时间复杂度降为常数，而差分数组则可以将区间修改的时间复杂度降为常数。  一、前缀和 前缀和知识点简单易理解，但出题难度较大，需要根据题意挖掘出潜在的前缀和关系，建立辅助数组求解问题。  （1）一维前缀和定义：  对数组 $x_0,x_1,x_2,…,x_n$，对其进行区间查询的时间复杂度是 $O(n)$ 为了提高区间查询的效率，可以引入前缀和数组 $y_0,y_1,…y_n$，前缀和数组有以下定义：$y_0 &#x3D; x_0\y_1 &#x3D; x_0 + x_1\y_2 &#x3D; x_0 + x_1 + x_2…$  创建方式：  由定义可知，前缀和数组有递推生成公式：$y_i &#x3D; y_{i-1} + x_i(i &gt; 0)$这个公式是生成前缀和数组的主要方式。  应用方式：  在创建前缀和数组以后，如果要查询原数组在区间[a,b]上的元素和，只需要使用公式 $y_b - y_{a-1}$ 即可在 $O(1)$ 的时间复杂度上求出区间元素和。  例题...</div></div></div></a><a class="pagination-related" href="/2025/03/11/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" title="滑动窗口"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-11</div><div class="info-item-2">滑动窗口</div></div><div class="info-2"><div class="info-item-1">滑动窗口（尺取法）算法含义：  在解决关于区间特性的题目时保存搜索区间左右端点，然后根据实际要求不断更新左右端点位置的算法  时间复杂度： $O(n)$空间复杂度： $O(1)$ 在历年真题中，滑动窗口主要有求追偿不重复子串和模拟优先队列求区间最值两个作用 一、求最长不重复字串 不重复子串：字符串的字串中不包含重复字符的字串  123456789101112131415161718from collections import defaultdicts = input()n = len(s)# 建立一个字典存储各个元素在窗口中出现的次数d = defaultdict(int)ans = 0# 确定窗口左端left = 0for right in range(n):    # 如果发现窗口中已经有s[right]，将left右移直到窗口中不存在s[right]    while d[s[right]] &gt; 0:        # 更新字典        d[s[left]] -= 1        left += 1    ans = max(ans,...</div></div></div></a><a class="pagination-related" href="/2025/03/11/%E7%B4%A0%E6%95%B0%E7%AD%9B/" title="素数筛"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-11</div><div class="info-item-2">素数筛</div></div><div class="info-2"><div class="info-item-1">素数筛暴力法时间复杂度: $O(n^2)$内层的 $is_prime()$ 函数使用遍历查找，其平均时间复杂度为 $O(\frac{n}{2})$，$sieve()$ 函数同样使用遍历查找，时间复杂度显然为 $O(n)$，对于该算法的循环结构，平均时间复杂度为 $O(\frac{n^2}{2}) &#x3D; O(n^2)$ 1234567891011121314def is_prime(num):    if num &lt; 2:  # 直接排除        return False    for i in range(2, num): # 遍历        if num % i == 0:            return False    return Truedef sieve(n):    primes = []    for i in range(2, n + 1):        if is_prime(i):            primes.append(i)    return primes $O(n\sqrt{n})$时间复杂度：...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/logo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">wyf</div><div class="author-info-description">记录生活，分享知识，记录成长</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wyf-cyber"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to visit my blog. If you have any questions, please leave a message to me. I will reply to you as soon as possible.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">蓝桥杯基础数论学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%EF%BC%9A"><span class="toc-number">1.0.1.</span> <span class="toc-text">目录：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%B4%A0%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">一、素数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%B1%82%E8%A7%A3%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">（1）求解方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%B1%82%E6%9C%80%E5%B0%8F%E8%B4%A8%E5%9B%A0%E6%95%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">（2）求最小质因数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.3.</span> <span class="toc-text">（3）欧拉函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8%E4%B8%80%EF%BC%9A%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97%E5%BC%8F"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">性质一：欧拉函数的计算式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8%E4%BA%8C%EF%BC%9A%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E8%A7%A3"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">性质二：欧拉函数的分解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E8%AE%BA%E4%B8%80%EF%BC%9A"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">推论一：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BE%8B%E9%A2%98%E6%BC%94%E7%A4%BA"><span class="toc-number">1.1.4.</span> <span class="toc-text">（4）例题演示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1%EF%BC%9A%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">例题 1：分解质因数**</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-2%EF%BC%9A%E4%BA%92%E8%B4%A8%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">例题 2：互质数的个数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BA%A6%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">二、约数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%B1%82%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">（1）求约数个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%B1%82%E6%89%80%E6%9C%89%E7%9A%84%E7%BA%A6%E6%95%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">（2）求所有的约数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">（3）最大公因数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0"><span class="toc-number">1.2.4.</span> <span class="toc-text">（4）最小公倍数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B9%82"><span class="toc-number">1.3.</span> <span class="toc-text">三、幂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%98%B6%E4%B9%98"><span class="toc-number">1.4.</span> <span class="toc-text">四、阶乘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1%EF%BC%9A%E6%B1%82%E9%98%B6%E4%B9%98%EF%BC%88%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AC%AC13%E5%B1%8A%E7%9C%81%E8%B5%9B%E7%9C%9F%E9%A2%98%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">例题 1：求阶乘（蓝桥杯第13届省赛真题）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-2%EF%BC%9A%E9%98%B6%E4%B9%98%E7%9A%84%E5%92%8C%EF%BC%88%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AC%AC14%E5%B1%8A%E7%9C%81%E8%B5%9B%E7%9C%9F%E9%A2%98%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">例题 2：阶乘的和（蓝桥杯第14届省赛真题）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%8F%96%E6%A8%A1"><span class="toc-number">1.5.</span> <span class="toc-text">五、取模</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%8A%A0%E5%87%8F%E4%B9%98%E4%B8%AD%E7%9A%84%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97"><span class="toc-number">1.5.1.</span> <span class="toc-text">（1）加减乘中的取模运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%99%A4%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97"><span class="toc-number">1.5.2.</span> <span class="toc-text">（2）除法中的取模运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E9%80%86%E5%85%83"><span class="toc-number">1.5.3.</span> <span class="toc-text">（3）逆元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%BC%82%E6%88%96-%E5%BC%82%E6%88%96%E5%92%8C"><span class="toc-number">1.6.</span> <span class="toc-text">六、异或 &amp; 异或和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">（1）基本性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1%EF%BC%9A%E5%BC%82%E6%88%96%E5%92%8C%EF%BC%88%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AC%AC14%E5%B1%8A%E7%9C%81%E8%B5%9B%EF%BC%89"><span class="toc-number">1.6.2.</span> <span class="toc-text">例题 1：异或和（蓝桥杯第14届省赛）</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/" title="组合问题">组合问题</a><time datetime="2025-03-11T05:52:15.988Z" title="发表于 2025-03-11 13:52:15">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/" title="子集问题">子集问题</a><time datetime="2025-03-11T05:51:34.469Z" title="发表于 2025-03-11 13:51:34">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98/" title="切割问题">切割问题</a><time datetime="2025-03-11T05:50:32.749Z" title="发表于 2025-03-11 13:50:32">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/" title="全排列问题">全排列问题</a><time datetime="2025-03-11T05:49:45.714Z" title="发表于 2025-03-11 13:49:45">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" title="双指针法在链表中的应用">双指针法在链表中的应用</a><time datetime="2025-03-11T05:47:23.716Z" title="发表于 2025-03-11 13:47:23">2025-03-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By wyf</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>